var fragmentShaderStr=new Array(17),vertexShaderStr="uniform mat4 modelViewProjectionMatrix;uniform mat4 modelViewMatrix;uniform mat3 normalMatrix;attribute vec3 vertex_position;attribute vec3 vertex_normal;varying vec3 view_position;varying vec3 view_normal; varying vec3 vertex_pos; void main(void){vec4 vpos = vec4(vertex_position, 1.0); gl_Position = modelViewProjectionMatrix * vpos;view_position = mat3(modelViewMatrix) * vertex_position;view_normal = normalize(normalMatrix * vertex_normal);vertex_pos = vertex_position;}",vertexShaderFlatStr="uniform mat4 modelViewProjectionMatrix;uniform mat4 modelViewMatrix;uniform mat3 normalMatrix;attribute vec3 vertex_position;attribute vec3 vertex_normal;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos;void main(void){vec4 vpos = vec4(vertex_position, 1.0);vpos.z = 0.0;gl_Position = modelViewProjectionMatrix * vpos;view_position = mat3(modelViewMatrix) * vertex_position;view_normal = normalize(normalMatrix * vertex_normal);vertex_pos = vertex_position;}";fragmentShaderStr[0]="precision mediump float; const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0;uniform vec3 diffuseColor;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos; void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 V = normalize(eyePosition - P);vec3 L = normalize(lightPosition - P);vec3 H = normalize(L + V);vec3 diffuseCol = diffuseColor; float diffuseFactor = max(dot(N, L), 0.0);vec3 diffuse = diffuseFactor * diffuseCol;float specular = pow(max(dot(N, H), 0.0), specularExponent);gl_FragColor.xyz = diffuse + specular;gl_FragColor.w = 1.0;}",fragmentShaderStr[1]="precision mediump float; const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos;void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 V = normalize(eyePosition - P);vec3 L = normalize(lightPosition - P);vec3 H = normalize(L + V);vec3 diffuseCol = N; float diffuseFactor = max(dot(N, L), 0.0);vec3 diffuse = diffuseFactor * diffuseCol;float specular = pow(max(dot(N, H), 0.0), specularExponent);gl_FragColor.xyz = diffuse + specular;gl_FragColor.w = 1.0;}",fragmentShaderStr[2]="precision mediump float; const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos; void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 V = normalize(eyePosition - P);vec3 L = normalize(lightPosition - P);vec3 H = normalize(L + V);vec3 diffuseCol = P; float diffuseFactor = max(dot(N, L), 0.0);vec3 diffuse = diffuseFactor * diffuseCol;float specular = pow(max(dot(N, H), 0.0), specularExponent);gl_FragColor.xyz = diffuse + specular;gl_FragColor.w = 1.0;}",fragmentShaderStr[3]="precision mediump float;const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos;vec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}vec4 mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}vec4 permute(vec4 x) {return mod289(((x * 34.0) + 1.0) * x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}float snoise(vec3 v){ const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0) ;const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);vec3 i = floor(v + dot(v, C.yyy) );vec3 x0 = v - i + dot(i, C.xxx) ;vec3 g = step(x0.yzx, x0.xyz);vec3 l = 1.0 - g;vec3 i1 = min( g.xyz, l.zxy );vec3 i2 = max( g.xyz, l.zxy );vec3 x1 = x0 - i1 + C.xxx;vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy;i = mod289(i); vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 ))+ i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));float n_ = 0.142857142857;vec3 ns = n_ * D.wyz - D.xzx;vec4 j = p - 49.0 * floor(p * ns.z * ns.z);vec4 x_ = floor(j * ns.z);vec4 y_ = floor(j - 7.0 * x_ );vec4 x = x_ *ns.x + ns.yyyy;vec4 y = y_ *ns.x + ns.yyyy;vec4 h = 1.0 - abs(x) - abs(y);vec4 b0 = vec4( x.xy, y.xy );vec4 b1 = vec4( x.zw, y.zw );vec4 s0 = floor(b0) * 2.0 + 1.0;vec4 s1 = floor(b1) * 2.0 + 1.0;vec4 sh = -step(h, vec4(0.0));vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;vec3 p0 = vec3(a0.xy, h.x);vec3 p1 = vec3(a0.zw, h.y);vec3 p2 = vec3(a1.xy, h.z);vec3 p3 = vec3(a1.zw, h.w);vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));p0 *= norm.x;p1 *= norm.y;p2 *= norm.z;p3 *= norm.w;vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);m = m * m;return 42.0 * dot( m*m, vec4( dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3) ) );}float turbulence(vec3 p){float t = 0.0;float s = 1.0;const float mins = (1.0 / 256.0);for(int i = 0; i < 8; i++){t += abs(snoise(p) * s);s = s * 0.5; p = 2.0 * p;}return t;}vec3 marbleColor(vec3 p){const float freq = 3.1415926535 * 1.0;const float scale = 5.0;const int octaves = 8;const vec3 c0 = vec3(0.8, 0.8, 0.8);const vec3 c1 = vec3(0.4, 0.2, 0.1);const vec3 c2 = vec3(0.06, 0.04, 0.02);float temp = scale * turbulence(freq * p);float t = 2.0 * abs(sin(freq * p.x + temp));vec3 col;if(t < 1.0)col = (c1 * t + (1.0 - t) * c2);else{t = t - 1.0;col = (c0 * t + (1.0 - t) * c1);}return col;} void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 V = normalize(eyePosition - P);vec3 L = normalize(lightPosition - P);vec3 H = normalize(L + V);vec3 diffuseCol = marbleColor(vertex_pos.xyz); float diffuseFactor = max(dot(N, L), 0.0);vec3 diffuse = diffuseFactor * diffuseCol;float specular = pow(max(dot(N, H), 0.0), specularExponent);gl_FragColor.xyz = diffuse + specular;gl_FragColor.w = 1.0;}",fragmentShaderStr[4]="precision mediump float;const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0;uniform vec3 diffuseColor;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos; void main(void){gl_FragColor.xyz = diffuseColor;gl_FragColor.w = 1.0;}",fragmentShaderStr[5]="precision mediump float; const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0; uniform vec3 diffuseColor;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos;void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 L = normalize(lightPosition - P);float diffuseFactor = max(dot(N, L), 0.0); vec3 color;float intensity = diffuseFactor;if (intensity > 0.95)color = vec3(1.0,0.5,0.5);else if (intensity > 0.5)color = vec3(0.6,0.3,0.3);else if (intensity > 0.25)color = vec3(0.4,0.2,0.2);else color = vec3(0.2,0.1,0.1);vec3 diffuse = color * diffuseColor; gl_FragColor.xyz = diffuse;gl_FragColor.w = 1.0;}",fragmentShaderStr[6]="precision mediump float; const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos; vec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}vec4 mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}vec4 permute(vec4 x) {return mod289(((x * 34.0) + 1.0) * x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}float snoise(vec3 v){ const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0) ;const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);vec3 i = floor(v + dot(v, C.yyy) );vec3 x0 = v - i + dot(i, C.xxx) ;vec3 g = step(x0.yzx, x0.xyz);vec3 l = 1.0 - g;vec3 i1 = min( g.xyz, l.zxy );vec3 i2 = max( g.xyz, l.zxy );vec3 x1 = x0 - i1 + C.xxx;vec3 x2 = x0 - i2 + C.yyy;vec3 x3 = x0 - D.yyy;i = mod289(i); vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 ))+ i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));float n_ = 0.142857142857;vec3 ns = n_ * D.wyz - D.xzx;vec4 j = p - 49.0 * floor(p * ns.z * ns.z);vec4 x_ = floor(j * ns.z);vec4 y_ = floor(j - 7.0 * x_ );vec4 x = x_ *ns.x + ns.yyyy;vec4 y = y_ *ns.x + ns.yyyy;vec4 h = 1.0 - abs(x) - abs(y);vec4 b0 = vec4( x.xy, y.xy );vec4 b1 = vec4( x.zw, y.zw );vec4 s0 = floor(b0) * 2.0 + 1.0;vec4 s1 = floor(b1) * 2.0 + 1.0;vec4 sh = -step(h, vec4(0.0));vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;vec3 p0 = vec3(a0.xy, h.x);vec3 p1 = vec3(a0.zw, h.y);vec3 p2 = vec3(a1.xy, h.z);vec3 p3 = vec3(a1.zw, h.w);vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));p0 *= norm.x;p1 *= norm.y;p2 *= norm.z;p3 *= norm.w;vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);m = m * m;return 42.0 * dot( m*m, vec4( dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3) ) );}float turbulence(vec3 p){float t = 0.0;float s = 1.0;const float mins = (1.0 / 256.0);for(int i = 0; i < 8; i++){t += abs(snoise(p) * s);s = s * 0.5;p = 2.0 * p;}return t;}vec3 cloudColor(vec3 p){float t;p = 0.1 * p;p.y = p.y * 0.3;t = turbulence(p);vec3 col = vec3(t, t, 1.0);return col;} void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 V = normalize(eyePosition - P);vec3 L = normalize(lightPosition - P);vec3 H = normalize(L + V);vec3 diffuseCol = cloudColor(vertex_pos); float diffuseFactor = max(dot(N, L), 0.0);vec3 diffuse = diffuseFactor * diffuseCol;float specular = pow(max(dot(N, H), 0.0), specularExponent);gl_FragColor.xyz = diffuse + specular;gl_FragColor.w = 1.0;}",fragmentShaderStr[7]="precision mediump float; const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0; uniform vec3 diffuseColor;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos;vec3 smoothBlackWhiteStripe(vec3 p, vec3 dcol, float w){vec3 col;float t = (1.0 + sin(3.1415926535 * p.x / w)) / 2.0; col = vec3(t * vec3(1.0, 1.0, 1.0) + (1.0 - t) * dcol);return col;} void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 V = normalize(eyePosition - P);vec3 L = normalize(lightPosition - P);vec3 H = normalize(L + V);vec3 diffuseCol = smoothBlackWhiteStripe(vertex_pos, diffuseColor, 0.05); float diffuseFactor = max(dot(N, L), 0.0);vec3 diffuse = diffuseFactor * diffuseCol;float specular = pow(max(dot(N, H), 0.0), specularExponent);gl_FragColor.xyz = diffuse + specular;gl_FragColor.w = 1.0;}",fragmentShaderStr[8]="precision mediump float; const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0;uniform float globalTime;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos;float hash(float n) { return fract(sin(n) * 753.5453123); }float noise2( in vec3 x ){vec3 p = floor(x);vec3 f = fract(x);f = f * f *(3.0 - 2.0 * f);float n = p.x + p.y * 157.0 + 113.0 * p.z;return mix(mix(mix( hash(n + 0.0), hash(n + 1.0), f.x),mix( hash(n + 157.0), hash(n + 158.0), f.x), f.y),mix(mix( hash(n + 113.0), hash(n + 114.0), f.x),mix( hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);} float n(vec3 x) {float s = noise2(x);for (float i = 2.0; i < 10.0; i++) s += noise2(x / i) / i; return s;} vec3 plasmaFieldColor(vec3 p){vec2 uv = p.xy * 30.0;float a = abs(n(vec3(uv + globalTime * 3.14, sin(globalTime))) - n(vec3(uv + globalTime, cos(globalTime + 3.0))));vec3 col = vec3(0.0, 0.5 - pow(a, 0.2) / 2.0, 1.0 - pow(a, 0.2));return col;} void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 V = normalize(eyePosition - P);vec3 L = normalize(lightPosition - P);vec3 H = normalize(L + V);vec3 diffuseCol = plasmaFieldColor(vertex_pos); float diffuseFactor = max(dot(N, L), 0.0);vec3 diffuse = diffuseFactor * diffuseCol;float specular = pow(max(dot(N, H), 0.0), specularExponent);gl_FragColor.xyz = diffuse + specular;gl_FragColor.w = 1.0;}",fragmentShaderStr[9]="precision mediump float; const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos;vec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}vec4 mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}vec4 permute(vec4 x) {return mod289(((x * 34.0) + 1.0) * x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}float snoise(vec3 v){ const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0) ;const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);vec3 i = floor(v + dot(v, C.yyy) );vec3 x0 = v - i + dot(i, C.xxx) ;vec3 g = step(x0.yzx, x0.xyz);vec3 l = 1.0 - g;vec3 i1 = min( g.xyz, l.zxy );vec3 i2 = max( g.xyz, l.zxy );vec3 x1 = x0 - i1 + C.xxx;vec3 x2 = x0 - i2 + C.yyy;vec3 x3 = x0 - D.yyy;i = mod289(i); vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 ))+ i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));float n_ = 0.142857142857;vec3 ns = n_ * D.wyz - D.xzx;vec4 j = p - 49.0 * floor(p * ns.z * ns.z);vec4 x_ = floor(j * ns.z);vec4 y_ = floor(j - 7.0 * x_ );vec4 x = x_ *ns.x + ns.yyyy;vec4 y = y_ *ns.x + ns.yyyy;vec4 h = 1.0 - abs(x) - abs(y);vec4 b0 = vec4( x.xy, y.xy );vec4 b1 = vec4( x.zw, y.zw );vec4 s0 = floor(b0) * 2.0 + 1.0;vec4 s1 = floor(b1) * 2.0 + 1.0;vec4 sh = -step(h, vec4(0.0));vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;vec3 p0 = vec3(a0.xy, h.x);vec3 p1 = vec3(a0.zw, h.y);vec3 p2 = vec3(a1.xy, h.z);vec3 p3 = vec3(a1.zw, h.w);vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));p0 *= norm.x;p1 *= norm.y;p2 *= norm.z;p3 *= norm.w;vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);m = m * m;return 42.0 * dot( m*m, vec4( dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3) ) );}float turbulence(vec3 p){float t = 0.0;float s = 1.0;const float mins = (1.0 / 256.0);for(int i = 0; i < 8; i++){t += abs(snoise(p) * s);s = s * 0.5;p = 2.0 * p;}return t;}vec3 sunSurfaceColor(vec3 p){const float freq = 3.1415926535 * 1.0;const float scale = 1.2;const int octaves = 8;const vec3 c0 = vec3(0.8, 0.7, 0.0);const vec3 c1 = vec3(0.6, 0.1, 0.0);float temp = scale * turbulence(freq * p);float t1 = 2.0 * abs(sin(freq * p.x + temp));float t2 = 2.0 * abs(sin(freq * p.y + temp)); float t3 = 2.0 * abs(sin(freq * p.z + temp)); float intensity = abs(t1 - 0.25) + abs(t2 - 0.25) + abs(t3 - 0.25); intensity = clamp(intensity * 0.25, 0.0, 1.0);vec3 col = mix(c0, c1, intensity); return col;} void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 V = normalize(eyePosition - P);vec3 L = normalize(lightPosition - P);vec3 H = normalize(L + V);vec3 diffuseCol = sunSurfaceColor(vertex_pos); float diffuseFactor = max(dot(N, L), 0.0);vec3 diffuse = diffuseFactor * diffuseCol;float specular = pow(max(dot(N, H), 0.0), specularExponent);gl_FragColor.xyz = diffuse + specular;gl_FragColor.w = 1.0;}",fragmentShaderStr[10]="precision mediump float; const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos;vec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}vec4 mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}vec4 permute(vec4 x) {return mod289(((x * 34.0) + 1.0) * x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}float snoise(vec3 v){ const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0) ;const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);vec3 i = floor(v + dot(v, C.yyy) );vec3 x0 = v - i + dot(i, C.xxx) ;vec3 g = step(x0.yzx, x0.xyz);vec3 l = 1.0 - g;vec3 i1 = min( g.xyz, l.zxy );vec3 i2 = max( g.xyz, l.zxy );vec3 x1 = x0 - i1 + C.xxx;vec3 x2 = x0 - i2 + C.yyy;vec3 x3 = x0 - D.yyy;i = mod289(i); vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 ))+ i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));float n_ = 0.142857142857;vec3 ns = n_ * D.wyz - D.xzx;vec4 j = p - 49.0 * floor(p * ns.z * ns.z);vec4 x_ = floor(j * ns.z);vec4 y_ = floor(j - 7.0 * x_ );vec4 x = x_ *ns.x + ns.yyyy;vec4 y = y_ *ns.x + ns.yyyy;vec4 h = 1.0 - abs(x) - abs(y);vec4 b0 = vec4( x.xy, y.xy );vec4 b1 = vec4( x.zw, y.zw );vec4 s0 = floor(b0) * 2.0 + 1.0;vec4 s1 = floor(b1) * 2.0 + 1.0;vec4 sh = -step(h, vec4(0.0));vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;vec3 p0 = vec3(a0.xy, h.x);vec3 p1 = vec3(a0.zw, h.y);vec3 p2 = vec3(a1.xy, h.z);vec3 p3 = vec3(a1.zw, h.w);vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));p0 *= norm.x;p1 *= norm.y;p2 *= norm.z;p3 *= norm.w;vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);m = m * m;return 42.0 * dot( m*m, vec4( dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3) ) );}float turbulence(vec3 p){float t = 0.0;float s = 1.0;const float mins = (1.0 / 256.0);for(int i = 0; i < 8; i++){t += abs(snoise(p) * s);s = s * 0.5;p = 2.0 * p;}return t;}vec3 graniteColor(vec3 p){const float freq = 3.1415926535 * 18.0;const float scale = 0.8;float temp = scale * turbulence(freq * p); vec3 col = vec3(temp, temp, temp);return col;}void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 V = normalize(eyePosition - P);vec3 L = normalize(lightPosition - P);vec3 H = normalize(L + V);vec3 diffuseCol = graniteColor(vertex_pos); float diffuseFactor = max(dot(N, L), 0.0);vec3 diffuse = diffuseFactor * diffuseCol;float specular = pow(max(dot(N, H), 0.0), specularExponent);gl_FragColor.xyz = diffuse + specular;gl_FragColor.w = 1.0;}",fragmentShaderStr[11]="precision mediump float; const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0;uniform vec3 diffuseColor;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos;void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 V = normalize(eyePosition - P);vec3 L = normalize(lightPosition - P);vec3 H = normalize(L + V);float diffuseFactor = max(dot(N, L), 0.0);const vec3 warmColor = vec3(1.0, 1.0, 0.0);const vec3 coolColor = vec3(0.0, 0.0, 1.0); float intval = (1.0 + dot(N, L)) / 2.0; vec3 kfinal = mix(coolColor, warmColor, intval);if (dot(N,V) < 0.25) kfinal = vec3(0.0, 0.0, 0.0);float specularFactor = pow(max(dot(N, H), 0.0), 32.0);vec3 specular = vec3(specularFactor, specularFactor, specularFactor);gl_FragColor = vec4(kfinal + specular, 1.0);}",fragmentShaderStr[12]="precision mediump float; const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0;uniform float globalTime;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos;float rand(vec2 n) {return fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}float simpleNoise(vec2 n) {const vec2 d = vec2(0.0, 1.0);vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);}float fbm(vec2 n) {float total = 0.0, amplitude = 1.0;for (int i = 0; i < 4; i++) {total += simpleNoise(n) * amplitude;n += n;amplitude *= 0.5;}return total;}vec3 fireColor(vec3 point){const vec3 c1 = vec3(0.5, 0.0, 0.1);const vec3 c2 = vec3(0.9, 0.3, 0.0);const vec3 c3 = vec3(0.2, 0.0, 0.0);const vec3 c4 = vec3(1.0, 0.9, 0.0);const vec3 c5 = vec3(0.1);const vec3 c6 = vec3(0.9);vec2 speed = vec2(1.4, 0.8);float shift = 1.6;vec2 p = (point.xy) * 8.0; float q = fbm(p - globalTime * 0.1);vec2 r = vec2(fbm(p + q + globalTime * speed.x - p.x - p.y), fbm(p + q - globalTime * speed.y));vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);vec3 color = vec3(c * cos(shift * point.y)); return color;} void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 V = normalize(eyePosition - P);vec3 L = normalize(lightPosition - P);vec3 H = normalize(L + V);vec3 diffuseCol = fireColor(vertex_pos); float diffuseFactor = max(dot(N, L), 0.0);vec3 diffuse = diffuseFactor * diffuseCol;float specular = pow(max(dot(N, H), 0.0), specularExponent);gl_FragColor.xyz = diffuse + specular;gl_FragColor.w = 1.0;}",fragmentShaderStr[13]="precision mediump float; const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0;uniform vec3 diffuseColor;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos;vec3 checker3DColor(vec3 p){vec3 color;const float scale = 25.0;float a = floor(p.x * scale);float b = floor(p.y * scale);if (mod(a + b, 2.0) > 0.5) color = vec3(0.5, 1.0, 0.5);else color = vec3(1.0, 0.5, 0.5);return color;} void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 V = normalize(eyePosition - P);vec3 L = normalize(lightPosition - P);vec3 H = normalize(L + V);vec3 diffuseCol = checker3DColor(vertex_pos); float diffuseFactor = max(dot(N, L), 0.0);vec3 diffuse = diffuseFactor * diffuseCol;float specular = pow(max(dot(N, H), 0.0), specularExponent);gl_FragColor.xyz = diffuse + specular;gl_FragColor.w = 1.0;}",fragmentShaderStr[14]="precision mediump float;const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos;vec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}vec4 mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}vec4 permute(vec4 x) {return mod289(((x * 34.0) + 1.0) * x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}float snoise(vec3 v){ const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0) ;const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);vec3 i = floor(v + dot(v, C.yyy) );vec3 x0 = v - i + dot(i, C.xxx) ;vec3 g = step(x0.yzx, x0.xyz);vec3 l = 1.0 - g;vec3 i1 = min( g.xyz, l.zxy );vec3 i2 = max( g.xyz, l.zxy );vec3 x1 = x0 - i1 + C.xxx;vec3 x2 = x0 - i2 + C.yyy;vec3 x3 = x0 - D.yyy; i = mod289(i); vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 ))+ i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));float n_ = 0.142857142857;vec3 ns = n_ * D.wyz - D.xzx;vec4 j = p - 49.0 * floor(p * ns.z * ns.z);vec4 x_ = floor(j * ns.z);vec4 y_ = floor(j - 7.0 * x_ );vec4 x = x_ *ns.x + ns.yyyy;vec4 y = y_ *ns.x + ns.yyyy;vec4 h = 1.0 - abs(x) - abs(y);vec4 b0 = vec4( x.xy, y.xy );vec4 b1 = vec4( x.zw, y.zw );;vec4 s0 = floor(b0) * 2.0 + 1.0;vec4 s1 = floor(b1) * 2.0 + 1.0;vec4 sh = -step(h, vec4(0.0));vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;vec3 p0 = vec3(a0.xy, h.x);vec3 p1 = vec3(a0.zw, h.y);vec3 p2 = vec3(a1.xy, h.z);vec3 p3 = vec3(a1.zw, h.w);vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));p0 *= norm.x;p1 *= norm.y;p2 *= norm.z;p3 *= norm.w;vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);m = m * m;return 42.0 * dot( m*m, vec4( dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3) ) );}vec3 marbleSharpColor(vec3 p){vec3 color;const float scale = 25.0;vec3 v = p * scale;float t = (v.x + 2.0 * v.y + 3.0 * v.z);t += 1.5 * snoise(v);float value = abs(sin(t));color = vec3(sqrt(value));return color;}void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 V = normalize(eyePosition - P);vec3 L = normalize(lightPosition - P);vec3 H = normalize(L + V);vec3 diffuseCol = marbleSharpColor(vertex_pos); float diffuseFactor = max(dot(N, L), 0.0);vec3 diffuse = diffuseFactor * diffuseCol;float specular = pow(max(dot(N, H), 0.0), specularExponent);gl_FragColor.xyz = diffuse + specular;gl_FragColor.w = 1.0;}",fragmentShaderStr[15]="precision mediump float;const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal;varying vec3 vertex_pos;vec3 brickColor(vec3 p){ const vec3 brickColor = vec3(1.0, 0.3, 0.2);const vec3 mortarColor = vec3(0.85, 0.86, 0.84);const vec2 brickSize = vec2(0.05, 0.025);const vec2 brickPct = vec2(0.9, 0.85);vec2 position = vertex_pos.xy/ brickSize;if(fract(position.y * 0.5) > 0.5)position.x += 0.5;position = fract(position);vec2 useBrick = step(position, brickPct);vec3 color = mix(mortarColor, brickColor, useBrick.x * useBrick.y);return color;} void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 V = normalize(eyePosition - P);vec3 L = normalize(lightPosition - P);vec3 H = normalize(L + V);vec3 diffuseCol = brickColor(vertex_pos); float diffuseFactor = max(dot(N, L), 0.0);vec3 diffuse = diffuseFactor * diffuseCol;float specular = pow(max(dot(N, H), 0.0), specularExponent);gl_FragColor.xyz = diffuse + specular;gl_FragColor.w = 1.0;}",fragmentShaderStr[16]="precision mediump float; const vec3 eyePosition = vec3(0.0, 0.0, 2.0);const vec3 lightPosition = vec3(0.0, 20, 40.0);const float specularExponent = 96.0;uniform vec3 diffuseColor;varying vec4 fragment_color;varying vec3 view_position;varying vec3 view_normal; varying vec3 vertex_pos;void main(void){vec3 P = view_position;vec3 N = normalize(view_normal);vec3 V = normalize(eyePosition - P);vec3 L = normalize(lightPosition - P);vec3 H = normalize(L + V);vec3 diffuseCol = vec3(0.5, 0.5, 0.5); float diffuseFactor = max(dot(N, L), 0.0);vec3 diffuse = diffuseFactor * diffuseCol;const float stride = 4.0;vec3 c = diffuse;float v = dot(c, c);vec2 p = gl_FragCoord.xy;p = mod(p.xx + vec2(p.y, -p.y), vec2(stride));gl_FragColor = vec4(vec3(float((v > 1.00) || (p.x != 0.0)) *float((v > 0.70) || (p.y != 0.0)) *float((v > 0.35) || (p.x != stride / 2.0)) *float((v > 0.18) || (p.y != stride / 2.0)) *float((v > 0.10) || (p.x != stride / 4.0)) *float((v > 0.02) || (p.y != stride / 4.0))), 1.0);}";
